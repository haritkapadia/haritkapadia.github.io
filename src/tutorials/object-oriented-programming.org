The Three Principles of Object-Oriented Programming

Object-oriented programming has become the most popular programming paradigm in the last few years. By understanding its core concepts well, one can greatly improve their understanding of many languages. The three principles of object-oriented programming are encapsulation, inheritance, and polymorphism.

* Encapsulation

Encapsulation is the process of containing private data in an object, and modifying the data using public methods. By containing the data that the user of of the object would like to modify, undefined behaviour is prevented and minimised. Below is an example of encapsulation.

#+BEGIN_SRC java
  public class Capsule {
      private String name;
      private double quantity;
      private boolean broken;

      Capsule(String name, double quantity) {
          this.name = name;
          this.quantity = quantity;
          this.broken = false;
      }

      public void break() {
          quantity = 0;
          broken = true;
      }

      public double getQuantity() {
          return quantity;
      }

      public boolean isBroken() {
          return broken;
      }
  }
#+END_SRC

In the example above, the ~Capsule~ class represents a capsule with a name, a quantity of medication, and a state of being broken.
By preventing the data of the ~Capsule~ from being modified, one prevents illogical actions from being performed, such as changing the ~name~ of the ~Capsule~.
Additionally, by containing data changes in methods, it is ensured that every required data change is made when an action is performed. This can be seen in the ~break()~ method, where the <span class="code">quantity</span> of the capsule is set to <span class="code">0</span> and the state of <span class="code">broken</span> is set to <span class="code">true</span>. If it was up to the programmer to make these changes to signify breaking the ~Capsule~, it is possible that they may forget to make one of these changes.

* Inheritance

Inheritance is the sharing of attributes between classes. Specifically, a class can inherit methods and fields from a different class. Some languages like Java enforce inheritance from one class, while others such as C++ support inheriting from multiple classes. Below is an example of single inheritance.

#+BEGIN_SRC java
  public class Parent {
      private String name;
      private Calendar birthDate;
      private double netWorth;

      public Parent(String name, Calendar birthDate) {
          this.name = name;
          this.birthDate = birthDate;
          netWorth = 0;
      }

      public void work(double hours) {
          netWorth += 14 * hours;
      }
  }

  public class Child extends Parent {
      private double happinessMeter;

      public Child(String name, Calendar birthDate) {
          super(name, birthDate);
          happinessMeter = 0;
      }

      public void play(double hours) {
          happinessMeter += 1.75 * hours;
      }

      public void idle(double hours) {
          happinessMeter -= 0.5 * hours;
      }
  }
#+END_SRC
  
In the example above, there are two classes, the ~Parent~ and the ~Child~.
The ~Parent~ can has a ~name~, a ~birthDate~, and a ~netWorth~. The ~Parent~ can ~work()~ to increase their ~netWorth~.
The Child class is inherits the methods of the ~Parent~, meaning the child also has a ~name~, a ~birthDate~, and a ~netWorth~. The child can also ~work()~. What is more interesting is that the ~Child~ also has attributes specific to itself, namely the ~happinessMeter~ and the ability to ~play()~.

* Polymorphism

Polymorphism is the ability to associate the same symbol with different actions depending on its context. This allows for the generalisation of actions within code. Below is an example of polymorphism.

#+BEGIN_SRC java
  public class Human {
      private String name;
      private Calendar birthDate;
      private boolean rested;

      public Human(String name, Calendar birthDate) {
          this.name = name;
          this.birthDate = birthDate;
          rested = false;
      }

      public void idle(double hours) {
          if(hours >= 1)
              rested = true;
      }


      public boolean isRested() {
          return rested;
      }
  }

  public class Parent extends Human{
      private double netWorth;

      public Parent(String name, Calendar birthDate) {
          super(name, birthDate);
          netWorth = 0;
      }

      public void work(double hours) {
          netWorth += 14 * hours;
      }
  }

  public class Child extends Parent {
      private double happinessMeter;

      public Child(String name, Calendar birthDate) {
          super(name, birthDate);
          happinessMeter = 0;
      }

      public void play(double hours) {
          happinessMeter += 1.75 * hours;
      }

      @Override
      public void idle(double hours) {
          happinessMeter -= 0.5 * hours;
      }
  }

  public class Driver {
      public static void main(String[] args) {
          Human[] humans = {
              new Human("A", new GregorianCalendar(2000, 10, 18)),
              new Child("B", new GregorianCalendar(2010, 5, 23))
          };
          for(int i = 0; i < humans.length; i++) {
              humans[i].idle(2.5);
              System.out.println(humans[i].isRested());
          }
      }
  }
#+END_SRC
  
In the example above, a ~Human~ class is created with an ~idle()~ method. An inheritor of the ~Human~ class, ~Child~, changes the behaviour of the method. When an array ~humans~ is created, it contains both a ~Human~ and a ~Child~ (an instance of polymorphism). When ~idle()~ is called on each object in the array, the method does something different for both the ~Human~ and the ~Child~ (another instance of polymorphism).
