<!DOCTYPE HTML>
<html lang="en">
  <head>
    <title>Harit Kapadia - Tutorials</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['\\(','\\)']]}});
    </script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Arimo&family=Inconsolata:wght@400;700;900&family=Zilla+Slab&display=swap');
    </style>
    <link rel="stylesheet" href="/style.css">

    <style>
      .section-number {
          display: none;
      }
    </style>
  </head>
  <body>
    <a class="topbar" href="/index.html">
      <div>HK</div>
    </a>
    <div class="row">
      <div class="col-1"></div>
      <div class="col-2">
        <h1>Principles of Recursion</h1>

        </div>
    </div>
    <div class="row">
      <div class="toc col-1"><ul><li><a href="#header-1"><span class="section-number">1</span>Origin in Mathematics</a></li>
<li><a href="#header-2"><span class="section-number">2</span>Recursion in Programming</a></li>
<li><a href="#header-3"><span class="section-number">3</span>Tail-end Recursion</a></li>
<li><a href="#header-4"><span class="section-number">4</span>Recursion in Programming</a></li>
</ul>
</div>
      <div class="content col-2"> <p>Recursion is a strategy of solving problems that involves nested and repeated code, often through the use of functions. It is used to solve problems that contain smaller versions of themselves.</p>
<p>Recursion, like many programming principles, originates in mathematics and has been extended and expanded.</p>
<h2 id="header-1"><span class="section-number">1</span>Origin in Mathematics</h2>
<p>In mathematics, a function \( f(x) \) is considered to be recursive if some transformation \( g(x) \) is applied to \( f(x) \) in its definition. For example, the function \( f(x) = 2 \cdot f(x - 1) \) is considered to be recursive as the function is used inside of its own definition. Additonally, functions often have base cases to ensure that the function can be evaluated. The previous function can be improved upon by transforming it into the following.</p>
<p>$$
f(x) = \left\{
\begin{array}{ll}
1, &#38; x = 0 \\
2 \cdot f(x - 1), &#38; x \gt 0 \\
\end{array}
\right.
$$</p>
<p>Expanding \( f(4) \) gives \( 2 \cdot f(3) \), which can be expanded further as: \( 2 \cdot f(3) = 2 \cdot 2 \cdot f(2) = 2 \cdot 2 \cdot 2 \cdot f(1) = 2 \cdot 2 \cdot 2 \cdot 2 \cdot f(0) = 16 \).</p>
<h2 id="header-2"><span class="section-number">2</span>Recursion in Programming</h2>
<p>Recursion in programming is very similar to recursion in mathematics. Below is the previously created function, implemented in Java.</p>
<pre class="prettyprint"><code class="language-java">  int f(int x) {
      if(x == 0)
          return 1;
      return 2 * f(x - 1);
  }</code>
</pre>
<p>The example above shows how a mathematical recursive function can be implemented in a programming language. In this case, the piecewise component is analogous to an if statement. Both functions are undefined when \( x \lt 0 \).</p>
<h2 id="header-3"><span class="section-number">3</span>Tail-end Recursion</h2>
<p>Programs often have a stack of memory allocated for them. When a function is called, the state of the current variables is stored and the function starts on a fresh slate. In recursive functions, a lot of space is taken up on the stack. However, many compiled languages can optimise recursion to be as efficient as any iterative solution, but for that the function must be tail-recursive.</p>
<p>A tail-recursive function is a function that ends its execution by returning only a value or only a function. The function created in the previous example is not tail-recursive due to the offending line below.</p>
<pre class="prettyprint"><code class="language-java">      return 2 * f(x - 1);</code>
</pre>
<p>To resolve this, the function can be modified as follows.</p>
<pre class="prettyprint"><code class="language-java">  int f(int x, int out) {
      if(x == 0)
          return out;
      return f(x - 1, 2 * out);
  }</code>
</pre>
<p>In the function above, a new parameter called <code>out</code> was created that would store the returned value. The function would have to be called as such: <code>f(/*number*/, 1)</code>.</p>
<h2 id="header-4"><span class="section-number">4</span>Recursion in Programming</h2>
<p>Recursion can make some problems very easy to approach. It makes code more expressive and allows problems to be solved using a divide and conquer strategy. Traversing a graph depth-first is often done recursively.</p>
 </div>
    </div>
  </body>
</html>
