Noncomparative Sorting

Sorting is a commonly performed task. The task of sorting can be divided into comparative and noncomparative sorting.

Comparative sorting is done by comparing two elements at a time, while noncomparative sorting uses the properties of numbers to rearrange lists. A common noncomparative sort is radix sort.

* Radix Sort

Radix sort continuously rearranges numbers by their place value. While this sort can be done with any base, a power of two is preferred on a computer because it is comfortable for the computer to operate in a base compatible with binary/bitwise operations. Below is an implementation of radix sort in Java.

#+BEGIN_SRC java
  public static void sort256(final int originalArr[]) {
      int[] arr = originalArr;
      // utility to find the current digit in base 256
      int digitGet = 0xFF;

      // a number that is up to 2^32 - 1 is represented in 4 digits (base 256). Another way of looking at it is that an int is 4 bytes large.
      for(int place = 0; place != 4; place++) {
          int[] count = new int[256];
          int[] copyArr = new int[arr.length];
          // counting the number of times each digit occurs in the array
          for(int i = 0; i != arr.length; i++) {
              int digit = (digitGet & arr[i]) >>> (8 * place);
              count[digit] += 1;
          }
          // determining the index of each element of the array based on the digit
          for(int i = 1; i != count.length; i++)
              count[i] += count[i-1];
          // reordering the array
          for(int i = arr.length - 1; i != -1; i--) {
              int digit = (digitGet & arr[i]) >>> (8 * place);
              copyArr[--count[digit]] = arr[i];
          }


          // reassigning the array
          arr = copyArr;
          digitGet <<= 8;
      }


      // copying the array into the original with negatives before positives
      int[] count = new int[2];
      for(int i = 0; i < arr.length; i++) {
          int digit = (int)(((1 << 63) & Double.doubleToLongBits(arr[i])) >>> (63));
          count[digit] += 1;
      }
      int i = 0;
      while(i != count[1])
          originalArr[i++] = arr[i + count[0] - 1];
      while(i != arr.length)
          originalArr[i++] = arr[i - count[1] - 1];
  }
#+END_SRC
  
This sort is in base \( 256 \), or \( 2^8 \), which is the size of one byte.

* Applications of Radix Sort

Radix sort is often used for sorting large lists of integral numbers. This is because the sort takes linear time, making it relatively faster than comparative sorts at extremely large list sizes.
